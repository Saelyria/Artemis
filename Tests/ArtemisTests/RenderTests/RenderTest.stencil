{% macro getAliasOf type aliasName %}{% typed type as Type %}
{% for alias in types.typealiases %}
{% if alias.aliasName == aliasName and alias.parentName == type.name %}
{{alias.typeName}}
{% endif %}
{% endfor %}
{% endmacro %}

{% for type in types.all where type.implements.RenderTestCase %}

{# The aliased type that this test is selecting (e.g. Int, String) #}
{% set _selType %}{% call getAliasOf type "SelectionType" %}{% endset %}
{% set selType %}{{_selType|removeNewlines}}{% endset %}

{# The aliased type that this test is selecting on (e.g. TestObject, TestInterface1) #}
{% set _selBase %}{% call getAliasOf type "SelectionBase" %}{% endset %}
{% set selBase %}{{_selBase|removeNewlines}}{% endset %}

{% set selTypeRes %}{{selType}}.Result{% endset %}

{# The property name that is used on the selection. If the property is on an interface, prepend an "iX_" #}
{% set _sel %}
{% if selBase|contains: "TestInterface" %}
i{{selBase|replace: "TestInterface", ""}}_{{_selType|removeNewlines|lowerFirstLetter}}
{% else %}
{{_selType|removeNewlines|lowerFirstLetter}}
{% endif %}
{% endset %}
{% set sel %}{{_sel|removeNewlines}}{% endset %}

{% set _selTrail %}
{% if selType == "TestObject" %}
 { $0.int }
{% endif %}
{% endset %}
{% set selTrail %} {{_selTrail|removeNewlines: "leading"}}{% endset %}
{% set renderSelTrail %}{{selTrail||replace: "$0.", ""|removeNewlines}}{% endset %}

{# An opening curly brace before a variable messes with Stencil - so, store it as a variable #}
{% set _o %} { {% endset %}
{% set o %}{{_o|removeNewlines}}{% endset %}
// sourcery:file:RenderTests/{{selBase}}/{{type.name}}.swift

import XCTest
@testable import Artemis

// MARK: - Tests to ensure single selections of {{selType}} and [{{selType}}] render as expected

extension {{type.name}} {
    func testSingleRender() {
        let query: _Operation<Query, {{selTypeRes}}> = .query {
            $0.{{sel}}{{selTrail}}
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}{{renderSelTrail}}}")
    }

    func testSingleArgsRender() {
        let query: _Operation<Query, {{selTypeRes}}> = .query {
            $0.{{sel}}Args(arguments: .testDefault){{selTrail}}
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}Args\(testArgs){{renderSelTrail}}}")
    }

    func testArrayRender() {
        let query: _Operation<Query, [{{selTypeRes}}]> = .query {
            $0.{{sel}}s{{selTrail}}
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}s{{renderSelTrail}}}")
    }

    func testArrayArgsRender() {
        let query: _Operation<Query, [{{selTypeRes}}]> = .query {
            $0.{{sel}}sArgs(arguments: .testDefault){{selTrail}}
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}sArgs\(testArgs){{renderSelTrail}}}")
    }
}

// MARK: - Tests to ensure single selections of {{selType}} and [{{selType}}] with aliases render as expected

extension {{type.name}} {
    func testSingleAliasRender() {
        let query: _Operation<Query, {{selTypeRes}}> = .query {
            $0.{{sel}}(alias: "alias"){{selTrail}}
        }
        XCTAssertEqual(query.render(), "{alias:{{sel}}{{renderSelTrail}}}")
    }

    func testSingleArgsAliasRender() {
        let query: _Operation<Query, {{selTypeRes}}> = .query {
            $0.{{sel}}Args(alias: "alias", arguments: .testDefault){{selTrail}}
        }
        XCTAssertEqual(query.render(), "{alias:{{sel}}Args\(testArgs){{renderSelTrail}}}")
    }

    func testArrayAliasRender() {
        let query: _Operation<Query, [{{selTypeRes}}]> = .query {
            $0.{{sel}}s(alias: "alias"){{selTrail}}
        }
        XCTAssertEqual(query.render(), "{alias:{{sel}}s{{renderSelTrail}}}")
    }

    func testArrayArgsAliasRender() {
        let query: _Operation<Query, [{{selTypeRes}}]> = .query {
            $0.{{sel}}sArgs(alias: "alias", arguments: .testDefault){{selTrail}}
        }
        XCTAssertEqual(query.render(), "{alias:{{sel}}sArgs\(testArgs){{renderSelTrail}}}")
    }
}

// MARK: - Tests to ensure multiple sibling selections of {{selType}} and [{{selType}}] render as expected

extension {{type.name}} {
    func testMultipleSingleRender() {
        let query: _Operation<Query, ({{selTypeRes}}, {{selTypeRes}})> = .query {
            $0.{{sel}}{{selTrail}}
            $0.{{sel}}{{selTrail}}
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}{{renderSelTrail}},{{sel}}{{renderSelTrail}}}")
    }

    func testMultipleSingleArgsRender() {
        let query: _Operation<Query, ({{selTypeRes}}, {{selTypeRes}})> = .query {
            $0.{{sel}}Args(arguments: .testDefault){{selTrail}}
            $0.{{sel}}Args(arguments: .testDefault){{selTrail}}
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}Args\(testArgs){{renderSelTrail}},{{sel}}Args\(testArgs){{renderSelTrail}}}")
    }

    func testMultipleArrayRender() {
        let query: _Operation<Query, ([{{selTypeRes}}], [{{selTypeRes}}])> = .query {
            $0.{{sel}}s{{selTrail}}
            $0.{{sel}}s{{selTrail}}
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}s{{renderSelTrail}},{{sel}}s{{renderSelTrail}}}")
    }

    func testMultipleArrayArgsRender() {
        let query: _Operation<Query, ([{{selTypeRes}}], [{{selTypeRes}}])> = .query {
            $0.{{sel}}sArgs(arguments: .testDefault){{selTrail}}
            $0.{{sel}}sArgs(arguments: .testDefault){{selTrail}}
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}sArgs\(testArgs){{renderSelTrail}},{{sel}}sArgs\(testArgs){{renderSelTrail}}}")
    }
}

// MARK: - Tests to ensure selections render as expected on selections of {{selType}} and [{{selType}}]

extension {{type.name}} {
    func testSingleOnObjectRender() {
        let query: _Operation<Query, Partial<TestObject>> = .query {
            $0.testObject {
                $0.{{sel}}{{selTrail}}
            }
        }
        XCTAssertEqual(query.render(), "{testObject{{o}}{{sel}}{{renderSelTrail}}}}")
    }

    func testSingleArgsOnObjectRender() {
        let query: _Operation<Query, Partial<TestObject>> = .query {
            $0.testObject {
                $0.{{sel}}Args(arguments: .testDefault){{selTrail}}
            }
        }
        XCTAssertEqual(query.render(), "{testObject{{o}}{{sel}}Args\(testArgs){{renderSelTrail}}}}")
    }

    func testArrayOnObjectRender() {
        let query: _Operation<Query, Partial<TestObject>> = .query {
            $0.testObject {
                $0.{{sel}}s{{selTrail}}
            }
        }
        XCTAssertEqual(query.render(), "{testObject{{o}}{{sel}}s{{renderSelTrail}}}}")
    }

    func testArrayArgsOnObjectRender() {
        let query: _Operation<Query, Partial<TestObject>> = .query {
            $0.testObject {
                $0.{{sel}}sArgs(arguments: .testDefault){{selTrail}}
            }
        }
        XCTAssertEqual(query.render(), "{testObject{{o}}{{sel}}sArgs\(testArgs){{renderSelTrail}}}}")
    }
}

// MARK: - Tests to ensure {{selType}} and [{{selType}}] can be selected on a sub-selection of Object

extension {{type.name}} {
    func testMultipleSingleOnObjectRender() {
        let query: _Operation<Query, Partial<TestObject>> = .query {
            $0.testObject {
                $0.{{sel}}{{selTrail}}
                $0.{{sel}}{{selTrail}}
            }
        }
        XCTAssertEqual(query.render(), "{testObject{{o}}{{sel}}{{renderSelTrail}},{{sel}}{{renderSelTrail}}}}")
    }

    func testMultipleSingleArgsOnObjectRender() {
        let query: _Operation<Query, Partial<TestObject>> = .query {
            $0.testObject {
                $0.{{sel}}Args(arguments: .testDefault){{selTrail}}
                $0.{{sel}}Args(arguments: .testDefault){{selTrail}}
            }
        }
        XCTAssertEqual(query.render(), "{testObject{{o}}{{sel}}Args\(testArgs){{renderSelTrail}},{{sel}}Args\(testArgs){{renderSelTrail}}}}")
    }

    func testMultipleArrayOnObjectRender() {
        let query: _Operation<Query, Partial<TestObject>> = .query {
            $0.testObject {
                $0.{{sel}}s{{selTrail}}
                $0.{{sel}}s{{selTrail}}
            }
        }
        XCTAssertEqual(query.render(), "{testObject{{o}}{{sel}}s{{renderSelTrail}},{{sel}}s{{renderSelTrail}}}}")
    }

    func testMultipleArrayArgsOnObjectRender() {
        let query: _Operation<Query, Partial<TestObject>> = .query {
            $0.testObject {
                $0.{{sel}}sArgs(arguments: .testDefault){{selTrail}}
                $0.{{sel}}sArgs(arguments: .testDefault){{selTrail}}
            }
        }
        XCTAssertEqual(query.render(), "{testObject{{o}}{{sel}}sArgs\(testArgs){{renderSelTrail}},{{sel}}sArgs\(testArgs){{renderSelTrail}}}}")
    }
}

// MARK: - Tests to ensure fragments on Query selecting {{selType}} and [{{selType}}] can be used at the top level of an operation

extension {{type.name}} {
    func testSingleOnFragmentRender() {
        let fragment = Fragment("fragName", on: Query.self) {
            $0.{{sel}}{{selTrail}}
        }
        let query: _Operation<Query, Never> = .query {
            fragment
        }
        XCTAssertEqual(query.render(), "{...fragName},fragment fragName on Query{{o}}{{sel}}{{renderSelTrail}}}")
    }

    func testSingleArgsOnFragmentRender() {
        let fragment = Fragment("fragName", on: Query.self) {
            $0.{{sel}}Args(arguments: .testDefault){{selTrail}}
        }
        let query: _Operation<Query, Never> = .query {
            fragment
        }
        XCTAssertEqual(query.render(), "{...fragName},fragment fragName on Query{{o}}{{sel}}Args\(testArgs){{renderSelTrail}}}")
    }

    func testArrayOnFragmentRender() {
        let fragment = Fragment("fragName", on: Query.self) {
            $0.{{sel}}s{{selTrail}}
        }
        let query: _Operation<Query, Never> = .query {
            fragment
        }
        XCTAssertEqual(query.render(), "{...fragName},fragment fragName on Query{{o}}{{sel}}s{{renderSelTrail}}}")
    }

    func testArrayArgsOnFragmentRender() {
        let fragment = Fragment("fragName", on: Query.self) {
            $0.{{sel}}sArgs(arguments: .testDefault){{selTrail}}
        }
        let query: _Operation<Query, Never> = .query {
            fragment
        }
        XCTAssertEqual(query.render(), "{...fragName},fragment fragName on Query{{o}}{{sel}}sArgs\(testArgs){{renderSelTrail}}}")
    }
}

{% if selType == "TestObject" %}
// MARK: - Tests to ensure fragments on {{selType}} can be used on selections of {{selType}} or [{{selType}}]

extension {{type.name}} {
    func testSingleOnObjectFragmentRender() {
        let fragment = Fragment("fragName", on: {{selType}}.self) {
            $0.int
        }
        let query: _Operation<Query, {{selTypeRes}}> = .query {
            $0.{{sel}} {
                fragment
            }
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}{...fragName}},fragment fragName on {{selType}}{int}")
    }

    func testSingleArgsOnObjectFragmentRender() {
        let fragment = Fragment("fragName", on: {{selType}}.self) {
            $0.int
        }
        let query: _Operation<Query, [{{selTypeRes}}]> = .query {
            $0.{{sel}}s {
                fragment
            }
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}s{...fragName}},fragment fragName on {{selType}}{int}")
    }

    func testArrayOnObjectFragmentRender() {
        let fragment = Fragment("fragName", on: {{selType}}.self) {
            $0.int
        }
        let query: _Operation<Query, {{selTypeRes}}> = .query {
            $0.{{sel}}Args(arguments: .testDefault) {
                fragment
            }
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}Args\(testArgs){...fragName}},fragment fragName on {{selType}}{int}")
    }

    func testArrayArgsOnObjectFragmentRender() {
        let fragment = Fragment("fragName", on: {{selType}}.self) {
            $0.int
        }
        let query: _Operation<Query, [{{selTypeRes}}]> = .query {
            $0.{{sel}}sArgs(arguments: .testDefault) {
                fragment
            }
        }
        XCTAssertEqual(query.render(), "{{o}}{{sel}}sArgs\(testArgs){...fragName}},fragment fragName on {{selType}}{int}")
    }
}
{% endif %}

// sourcery:end

{% endfor %}
